{"version":3,"file":"soda.umd.js","sources":["../lib.esm/crypto/crypto-browser.js","../lib.esm/soda.js"],"sourcesContent":["import CryptoJS from \"crypto-js\";\nimport { ethers } from \"ethers\";\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nexport async function generateRSAKeyPair() {\n    // Generate a new RSA key pair\n    const keyPair = await crypto.subtle.generateKey({\n        name: \"RSA-OAEP\",\n        modulusLength: 2048,\n        publicExponent: new Uint8Array([1, 0, 1]),\n        hash: { name: \"SHA-256\" },\n    }, true, [\"encrypt\", \"decrypt\"]);\n    const publicKey = await crypto.subtle.exportKey(\"spki\", keyPair.publicKey);\n    const privateKey = await crypto.subtle.exportKey(\"pkcs8\", keyPair.privateKey);\n    return { publicKey, privateKey };\n}\nexport function decryptAES(key, r, ciphertext) {\n    const blockSize = 16; // 128 bits\n    const keyBytes = CryptoJS.enc.Hex.parse(key);\n    const rBytes = CryptoJS.enc.Hex.parse(r);\n    const ciphertextBytes = CryptoJS.enc.Hex.parse(ciphertext);\n    if (ciphertextBytes.sigBytes !== blockSize) {\n        throw new RangeError(\"Ciphertext size must be 128 bits.\");\n    }\n    if (keyBytes.sigBytes !== blockSize) {\n        throw new RangeError(\"Key size must be 128 bits.\");\n    }\n    if (rBytes.sigBytes !== blockSize) {\n        throw new RangeError(\"Random size must be 128 bits.\");\n    }\n    // Encrypt the random value 'r' using AES in ECB mode\n    const encryptedR = CryptoJS.AES.encrypt(rBytes, keyBytes, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding });\n    // XOR the encrypted random value 'r' with the ciphertext to obtain the plaintext\n    const plaintextWords = encryptedR.ciphertext.words.map((word, i) => word ^ ciphertextBytes.words[i]);\n    const plaintext = CryptoJS.lib.WordArray.create(plaintextWords).toString(CryptoJS.enc.Hex);\n    return plaintext;\n}\nexport function decryptValue(ctAmount, userKey) {\n    const blockSize = 16; // 128 bits\n    const hexBase = 16;\n    // Convert CT to hex string\n    let ctString = ctAmount.toString(hexBase);\n    let ctArray = CryptoJS.enc.Hex.parse(ctString);\n    while (ctArray.sigBytes < 32) {\n        // When the first bits are 0, bigint bit size is less than 32 and need to re-add the bits\n        ctString = \"0\" + ctString;\n        ctArray = CryptoJS.enc.Hex.parse(ctString);\n    }\n    // Split CT into two 128-bit arrays r and cipher\n    const cipherHex = ctArray.toString(CryptoJS.enc.Hex).substring(0, blockSize * 2);\n    const rHex = ctArray.toString(CryptoJS.enc.Hex).substring(blockSize * 2);\n    // Decrypt the cipher\n    const decryptedMessageHex = decryptAES(userKey, rHex, cipherHex);\n    return parseInt(decryptedMessageHex, hexBase);\n}\nexport function prepareMessage(plaintext, wallet, aesKey, contractAddress, functionSelector) {\n    // Convert the plaintext to a hex string\n    const plaintextHex = plaintext.toString(16).padStart(16, '0'); // Ensure it's 8 bytes (16 hex chars)\n    // Encrypt the plaintext using AES key\n    const { ciphertext, r } = encryptAES(aesKey, plaintextHex);\n    const ct = ciphertext + r;\n    const messageHash = ethers.solidityPackedKeccak256([\"address\", \"address\", \"bytes4\", \"uint256\"], [wallet.address, contractAddress, functionSelector, BigInt(\"0x\" + ct)]);\n    const ctInt = BigInt(\"0x\" + ct);\n    return { ctInt, messageHash };\n}\nexport function encryptAES(key, plaintext) {\n    const blockSize = 16; // 128 bits\n    const keyBytes = CryptoJS.enc.Hex.parse(key);\n    // Generate a random value 'r' of the same length as the block size\n    const r = CryptoJS.lib.WordArray.random(blockSize);\n    // Encrypt the random value 'r' using AES in ECB mode\n    const encryptedR = CryptoJS.AES.encrypt(r, keyBytes, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding });\n    // Pad the plaintext with zeros if it's smaller than the block size\n    const plaintextPadded = CryptoJS.enc.Hex.parse(plaintext.padStart(blockSize * 2, '0'));\n    // XOR the encrypted random value 'r' with the plaintext to obtain the ciphertext\n    const ciphertextWords = encryptedR.ciphertext.words.map((word, i) => word ^ plaintextPadded.words[i]);\n    const ciphertext = CryptoJS.lib.WordArray.create(ciphertextWords).toString(CryptoJS.enc.Hex);\n    return { ciphertext, r: r.toString(CryptoJS.enc.Hex) };\n}\nexport function signRawMessage(message, walletSigningKey) {\n    const key = new ethers.SigningKey(walletSigningKey);\n    const sig = key.sign(message);\n    return Buffer.concat([ethers.getBytes(sig.r), ethers.getBytes(sig.s), ethers.getBytes(`0x0${sig.v - 27}`)]);\n}\nexport async function decryptRSA(privateKey, encryptedData) {\n    return await crypto.subtle.decrypt({\n        name: \"RSA-OAEP\"\n    }, privateKey, encryptedData);\n}\n// async function importRSAPrivateKey(privateKeyData: ArrayBuffer): Promise<any> {\n//     return await crypto.subtle.importKey(\n//         \"pkcs8\",\n//         privateKeyData,\n//         {\n//             name: \"RSA-OAEP\",\n//             hash: { name: \"SHA-256\" }\n//         },\n//         true,\n//         [\"decrypt\"]\n//     );\n// }\n//# sourceMappingURL=crypto-browser.js.map","export { generateRSAKeyPair, } from \"./crypto/index.js\";\n/////////////////////////////\n// Types\n// export type { ProgressCallback, SignatureLike } from \"./crypto/index.js\";\n// dummy change; to pick-up ws security issue changes\n//# sourceMappingURL=soda.js.map"],"names":[],"mappings":";;;;;;;IAEA,SAAS,SAAS,GAAG;IACrB,IAAI,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE;IACrC,QAAQ,OAAO,IAAI,CAAC;IACpB,KAAK;IACL,IAAI,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;IACvC,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK;IACL,IAAI,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;IACvC,QAAQ,OAAO,MAAM,CAAC;IACtB,KAAK;IACL,IAAI,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;IACtD,CAAC;IAED,MAAM,SAAS,GAAG,SAAS,EAAE,CAAC;IAC9B,MAAM,MAAM,GAAG,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,QAAQ,CAAC;IAC/C,eAAe,kBAAkB,GAAG;IAC3C;IACA,IAAI,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC;IACpD,QAAQ,IAAI,EAAE,UAAU;IACxB,QAAQ,aAAa,EAAE,IAAI;IAC3B,QAAQ,cAAc,EAAE,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;IACjD,QAAQ,IAAI,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE;IACjC,KAAK,EAAE,IAAI,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;IACrC,IAAI,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;IAC/E,IAAI,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;IAClF,IAAI,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,CAAC;IACrC,CAAC;IA0ED;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IChHA;IACA;IACA;IACA;;;;;;;;;;;;;;"}