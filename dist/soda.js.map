{"version":3,"file":"soda.js","sources":["../lib.esm/crypto/crypto-browser.js","../lib.esm/soda.js"],"sourcesContent":["import CryptoJS from \"crypto-js\";\nfunction getGlobal() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n}\n;\nconst anyGlobal = getGlobal();\nconst crypto = anyGlobal.crypto || anyGlobal.msCrypto;\nexport async function generateRSAKeyPair() {\n    // Generate a new RSA key pair\n    const keyPair = await crypto.subtle.generateKey({\n        name: \"RSA-OAEP\",\n        modulusLength: 2048,\n        publicExponent: new Uint8Array([1, 0, 1]),\n        hash: { name: \"SHA-256\" },\n    }, true, [\"encrypt\", \"decrypt\"]);\n    const publicKey = await crypto.subtle.exportKey(\"spki\", keyPair.publicKey);\n    const privateKey = await crypto.subtle.exportKey(\"pkcs8\", keyPair.privateKey);\n    return { publicKey, privateKey };\n}\nexport function encryptAES(plaintext, key) {\n    const blockSize = 16; // 128 bits\n    // Convert Uint8Array to WordArray\n    const keyBytes = CryptoJS.lib.WordArray.create(key);\n    // Generate a random value 'r' of the same length as the block size\n    const r = CryptoJS.lib.WordArray.random(blockSize);\n    // Encrypt the random value 'r' using AES in ECB mode\n    const encryptedR = CryptoJS.AES.encrypt(r, keyBytes, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding });\n    // Pad the plaintext with zeros if it's smaller than the block size\n    const plaintextPadded = CryptoJS.lib.WordArray.create(plaintext);\n    const paddingLength = blockSize - (plaintextPadded.sigBytes % blockSize);\n    for (let i = 0; i < paddingLength; i++) {\n        plaintextPadded.concat(CryptoJS.lib.WordArray.create([0], 1));\n    }\n    // XOR the encrypted random value 'r' with the plaintext to obtain the ciphertext\n    const ciphertextWords = encryptedR.ciphertext.words.map((word, i) => word ^ plaintextPadded.words[i]);\n    const ciphertext = CryptoJS.lib.WordArray.create(ciphertextWords, blockSize).toString(CryptoJS.enc.Hex);\n    return { ciphertext, r: r.toString(CryptoJS.enc.Hex) };\n}\nexport function decryptAES(ciphertext, key, r) {\n    const blockSize = 16; // 128 bits\n    // Convert Uint8Array to WordArray\n    const keyBytes = uint8ArrayToWordArray(key);\n    const rBytes = uint8ArrayToWordArray(r);\n    const ciphertextBytes = uint8ArrayToWordArray(ciphertext);\n    if (ciphertextBytes.sigBytes !== blockSize) {\n        throw new RangeError(\"Ciphertext size must be 128 bits.\");\n    }\n    if (keyBytes.sigBytes !== blockSize) {\n        throw new RangeError(\"Key size must be 128 bits.\");\n    }\n    if (rBytes.sigBytes !== blockSize) {\n        throw new RangeError(\"Random size must be 128 bits.\");\n    }\n    // Encrypt the random value 'r' using AES in ECB mode\n    const encryptedR = CryptoJS.AES.encrypt(rBytes, keyBytes, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding });\n    // XOR the encrypted random value 'r' with the ciphertext to obtain the plaintext\n    const plaintextWords = encryptedR.ciphertext.words.map((word, i) => word ^ ciphertextBytes.words[i]);\n    const plaintext = CryptoJS.lib.WordArray.create(plaintextWords, blockSize);\n    // Convert WordArray back to Uint8Array\n    return wordArrayToUint8Array(plaintext);\n}\n// Utility function to convert Uint8Array to WordArray\nfunction uint8ArrayToWordArray(u8Array) {\n    const words = [];\n    for (let i = 0; i < u8Array.length; i++) {\n        words[i >>> 2] |= u8Array[i] << (24 - (i % 4) * 8);\n    }\n    return CryptoJS.lib.WordArray.create(words, u8Array.length);\n}\n// Utility function to convert WordArray to Uint8Array\nfunction wordArrayToUint8Array(wordArray) {\n    const len = wordArray.sigBytes;\n    const words = wordArray.words;\n    const u8Array = new Uint8Array(len);\n    for (let i = 0; i < len; i++) {\n        u8Array[i] = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n    }\n    return u8Array;\n}\nexport function decryptValue(ctAmount, userKey) {\n    throw new Error(\"Not implemented in the browser\");\n}\nexport function prepareMessage(plaintext, wallet, aesKey, contractAddress, functionSelector) {\n    throw new Error(\"Not implemented in the browser\");\n}\nexport function signRawMessage(message, walletSigningKey) {\n    throw new Error(\"Not implemented in the browser\");\n}\nexport async function decryptRSA(privateKey, encryptedData) {\n    return await crypto.subtle.decrypt({\n        name: \"RSA-OAEP\"\n    }, privateKey, encryptedData);\n}\n//\n// export async function importRSAPrivateKey(privateKeyData: ArrayBuffer): Promise<any> {\n//     return await crypto.subtle.importKey(\n//         \"pkcs8\",\n//         privateKeyData,\n//         {\n//             name: \"RSA-OAEP\",\n//             hash: { name: \"SHA-256\" }\n//         },\n//         true,\n//         [\"decrypt\"]\n//     );\n// }\n//\n// export function sign(message: string, privateKey: string) {\n//   const key = new SigningKey(privateKey);\n//   const sig = key.sign(message);\n//   return Buffer.concat([getBytes(sig.r), getBytes(sig.s), getBytes(`0x0${sig.v - 27}`)]);\n// }\n//\n//\n// function encryptWithAESKey(key: string, plaintext: string): { ciphertext: string, r: string } {\n//     const blockSize = 16; // 128 bits\n//     const keyBytes = CryptoJS.enc.Hex.parse(key);\n//\n//     // Generate a random value 'r' of the same length as the block size\n//     const r = CryptoJS.lib.WordArray.random(blockSize);\n//\n//     // Encrypt the random value 'r' using AES in ECB mode\n//     const encryptedR = CryptoJS.AES.encrypt(r, keyBytes, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding });\n//\n//     // Pad the plaintext with zeros if it's smaller than the block size\n//     const plaintextPadded = CryptoJS.enc.Hex.parse(plaintext.padStart(blockSize * 2, '0'));\n//\n//     // XOR the encrypted random value 'r' with the plaintext to obtain the ciphertext\n//     const ciphertextWords = encryptedR.ciphertext.words.map((word, i) => word ^ plaintextPadded.words[i]);\n//\n//     const ciphertext = CryptoJS.lib.WordArray.create(ciphertextWords).toString(CryptoJS.enc.Hex);\n//\n//     return { ciphertext, r: r.toString(CryptoJS.enc.Hex) };\n// }\n//\n// // AES-128-ECB Decryption\n// function decryptWithAESKey(key: string, r: string, ciphertext: string): string {\n//     const blockSize = 16; // 128 bits\n//     const keyBytes = CryptoJS.enc.Hex.parse(key);\n//     const rBytes = CryptoJS.enc.Hex.parse(r);\n//     const ciphertextBytes = CryptoJS.enc.Hex.parse(ciphertext);\n//\n//     if (ciphertextBytes.sigBytes !== blockSize) {\n//         throw new RangeError(\"Ciphertext size must be 128 bits.\");\n//     }\n//\n//     if (keyBytes.sigBytes !== blockSize) {\n//         throw new RangeError(\"Key size must be 128 bits.\");\n//     }\n//\n//     if (rBytes.sigBytes !== blockSize) {\n//         throw new RangeError(\"Random size must be 128 bits.\");\n//     }\n//\n//     // Encrypt the random value 'r' using AES in ECB mode\n//     const encryptedR = CryptoJS.AES.encrypt(rBytes, keyBytes, { mode: CryptoJS.mode.ECB, padding: CryptoJS.pad.NoPadding });\n//\n//     // XOR the encrypted random value 'r' with the ciphertext to obtain the plaintext\n//     const plaintextWords = encryptedR.ciphertext.words.map((word, i) => word ^ ciphertextBytes.words[i]);\n//     const plaintext = CryptoJS.lib.WordArray.create(plaintextWords).toString(CryptoJS.enc.Hex);\n//\n//     return plaintext;\n// }\n//\n// export function decryptValue(ctAmount: bigint, userKey: string): number {\n//     const blockSize = 16; // 128 bits\n//     const hexBase = 16;\n//\n//     // Convert CT to hex string\n//     let ctString = ctAmount.toString(hexBase);\n//     let ctArray = CryptoJS.enc.Hex.parse(ctString);\n//\n//     while (ctArray.sigBytes < 32) {\n//         // When the first bits are 0, bigint bit size is less than 32 and need to re-add the bits\n//         ctString = \"0\" + ctString;\n//         ctArray = CryptoJS.enc.Hex.parse(ctString);\n//     }\n//\n//     // Split CT into two 128-bit arrays r and cipher\n//     const cipherHex = ctArray.toString(CryptoJS.enc.Hex).substring(0, blockSize * 2);\n//     const rHex = ctArray.toString(CryptoJS.enc.Hex).substring(blockSize * 2);\n//\n//     // Decrypt the cipher\n//     const decryptedMessageHex = decryptWithAESKey(userKey, rHex, cipherHex);\n//\n//     return parseInt(decryptedMessageHex, hexBase);\n// }\n//\n// export async function prepareIT(\n//     plaintext: bigint,\n//     walletAddress: string,\n//     walletPrivateKey: string,\n//     userKey: string,\n//     contractAddress: string,\n//     functionSelector: string,\n// ) {\n//     // Convert the plaintext to a hex string\n//     const plaintextHex = plaintext.toString(16).padStart(16, '0'); // Ensure it's 8 bytes (16 hex chars)\n//\n//     // Encrypt the plaintext using AES key\n//     const { ciphertext, r } = encryptWithAESKey(userKey, plaintextHex);\n//     const ct = ciphertext + r;\n//     const message = solidityPackedKeccak256(\n//         [\"address\", \"address\", \"bytes4\", \"uint256\"],\n//         [walletAddress, contractAddress, functionSelector, BigInt(\"0x\" + ct)],\n//     );\n//\n//     const signature = sign(message, walletPrivateKey);\n//\n//     // Convert the ciphertext to BigInt\n//     const ctInt = BigInt(\"0x\" + ct);\n//\n//     return { encryptedSecret: ctInt, signature};\n// }\n//# sourceMappingURL=crypto-browser.js.map","export { generateRSAKeyPair, } from \"./crypto/index.js\";\n/////////////////////////////\n// Types\n// export type { ProgressCallback, SignatureLike } from \"./crypto/index.js\";\n// dummy change; to pick-up ws security issue changes\n//# sourceMappingURL=soda.js.map"],"names":[],"mappings":";;;AACA,SAAS,SAAS,GAAG;AACrB,IAAI,IAAI,OAAO,IAAI,KAAK,WAAW,EAAE;AACrC,QAAQ,OAAO,IAAI,CAAC;AACpB,KAAK;AACL,IAAI,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;AACvC,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,IAAI,OAAO,MAAM,KAAK,WAAW,EAAE;AACvC,QAAQ,OAAO,MAAM,CAAC;AACtB,KAAK;AACL,IAAI,MAAM,IAAI,KAAK,CAAC,gCAAgC,CAAC,CAAC;AACtD,CAAC;AAED,MAAM,SAAS,GAAG,SAAS,EAAE,CAAC;AAC9B,MAAM,MAAM,GAAG,SAAS,CAAC,MAAM,IAAI,SAAS,CAAC,QAAQ,CAAC;AAC/C,eAAe,kBAAkB,GAAG;AAC3C;AACA,IAAI,MAAM,OAAO,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,WAAW,CAAC;AACpD,QAAQ,IAAI,EAAE,UAAU;AACxB,QAAQ,aAAa,EAAE,IAAI;AAC3B,QAAQ,cAAc,EAAE,IAAI,UAAU,CAAC,CAAC,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC;AACjD,QAAQ,IAAI,EAAE,EAAE,IAAI,EAAE,SAAS,EAAE;AACjC,KAAK,EAAE,IAAI,EAAE,CAAC,SAAS,EAAE,SAAS,CAAC,CAAC,CAAC;AACrC,IAAI,MAAM,SAAS,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,MAAM,EAAE,OAAO,CAAC,SAAS,CAAC,CAAC;AAC/E,IAAI,MAAM,UAAU,GAAG,MAAM,MAAM,CAAC,MAAM,CAAC,SAAS,CAAC,OAAO,EAAE,OAAO,CAAC,UAAU,CAAC,CAAC;AAClF,IAAI,OAAO,EAAE,SAAS,EAAE,UAAU,EAAE,CAAC;AACrC,CAAC;AA2ED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7NA;AACA;AACA;AACA;;;;;;;;;"}