const __$G=typeof globalThis!=="undefined"?globalThis:typeof window!=="undefined"?window:typeof global!=="undefined"?global:typeof self!=="undefined"?self:{};(function(global,factory){typeof exports==="object"&&typeof module!=="undefined"?factory(exports,require("crypto-js")):typeof define==="function"&&define.amd?define(["exports","crypto-js"],factory):(global=typeof globalThis!=="undefined"?globalThis:global||self,factory(global.soda={},global.CryptoJS))})(this,function(exports,CryptoJS){"use strict";const version="6.13.1";function checkType(value,type,name){const types=type.split("|").map(t=>t.trim());for(let i=0;i<types.length;i++){switch(type){case"any":return;case"bigint":case"boolean":case"number":case"string":if(typeof value===type){return}}}const error=new Error(`invalid value for type ${type}`);error.code="INVALID_ARGUMENT";error.argument=`value.${name}`;error.value=value;throw error}function defineProperties(target,values,types){for(let key in values){let value=values[key];const type=types?types[key]:null;if(type){checkType(value,type,key)}Object.defineProperty(target,key,{enumerable:true,value:value,writable:false})}}function stringify(value){if(value==null){return"null"}if(Array.isArray(value)){return"[ "+value.map(stringify).join(", ")+" ]"}if(value instanceof Uint8Array){const HEX="0123456789abcdef";let result="0x";for(let i=0;i<value.length;i++){result+=HEX[value[i]>>4];result+=HEX[value[i]&15]}return result}if(typeof value==="object"&&typeof value.toJSON==="function"){return stringify(value.toJSON())}switch(typeof value){case"boolean":case"symbol":return value.toString();case"bigint":return BigInt(value).toString();case"number":return value.toString();case"string":return JSON.stringify(value);case"object":{const keys=Object.keys(value);keys.sort();return"{ "+keys.map(k=>`${stringify(k)}: ${stringify(value[k])}`).join(", ")+" }"}}return`[ COULD NOT SERIALIZE ]`}function makeError(message,code,info){let shortMessage=message;{const details=[];if(info){if("message"in info||"code"in info||"name"in info){throw new Error(`value will overwrite populated values: ${stringify(info)}`)}for(const key in info){if(key==="shortMessage"){continue}const value=info[key];details.push(key+"="+stringify(value))}}details.push(`code=${code}`);details.push(`version=${version}`);if(details.length){message+=" ("+details.join(", ")+")"}}let error;switch(code){case"INVALID_ARGUMENT":error=new TypeError(message);break;case"NUMERIC_FAULT":case"BUFFER_OVERRUN":error=new RangeError(message);break;default:error=new Error(message)}defineProperties(error,{code:code});if(info){Object.assign(error,info)}if(error.shortMessage==null){defineProperties(error,{shortMessage:shortMessage})}return error}function assert(check,message,code,info){if(!check){throw makeError(message,code,info)}}function assertArgument(check,message,name,value){assert(check,message,"INVALID_ARGUMENT",{argument:name,value:value})}const _normalizeForms=["NFD","NFC","NFKD","NFKC"].reduce((accum,form)=>{try{if("test".normalize(form)!=="test"){throw new Error("bad")}if(form==="NFD"){const check=String.fromCharCode(233).normalize("NFD");const expected=String.fromCharCode(101,769);if(check!==expected){throw new Error("broken")}}accum.push(form)}catch(error){}return accum},[]);function assertNormalize(form){assert(_normalizeForms.indexOf(form)>=0,"platform missing String.prototype.normalize","UNSUPPORTED_OPERATION",{operation:"String.prototype.normalize",info:{form:form}})}function assertPrivate(givenGuard,guard,className){if(className==null){className=""}if(givenGuard!==guard){let method=className,operation="new";if(className){method+=".";operation+=" "+className}assert(false,`private constructor; use ${method}from* methods`,"UNSUPPORTED_OPERATION",{operation:operation})}}function _getBytes(value,name,copy){if(value instanceof Uint8Array){if(copy){return new Uint8Array(value)}return value}if(typeof value==="string"&&value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)){const result=new Uint8Array((value.length-2)/2);let offset=2;for(let i=0;i<result.length;i++){result[i]=parseInt(value.substring(offset,offset+2),16);offset+=2}return result}assertArgument(false,"invalid BytesLike value",name||"value",value)}function getBytes(value,name){return _getBytes(value,name,false)}function getBytesCopy(value,name){return _getBytes(value,name,true)}function isHexString(value,length){if(typeof value!=="string"||!value.match(/^0x[0-9A-Fa-f]*$/)){return false}if(typeof length==="number"&&value.length!==2+2*length){return false}if(length===true&&value.length%2!==0){return false}return true}const HexCharacters="0123456789abcdef";function hexlify(data){const bytes=getBytes(data);let result="0x";for(let i=0;i<bytes.length;i++){const v=bytes[i];result+=HexCharacters[(v&240)>>4]+HexCharacters[v&15]}return result}function concat(datas){return"0x"+datas.map(d=>hexlify(d).substring(2)).join("")}function dataLength(data){if(isHexString(data,true)){return(data.length-2)/2}return getBytes(data).length}function zeroPad(data,length,left){const bytes=getBytes(data);assert(length>=bytes.length,"padding exceeds data length","BUFFER_OVERRUN",{buffer:new Uint8Array(bytes),length:length,offset:length+1});const result=new Uint8Array(length);result.fill(0);if(left){result.set(bytes,length-bytes.length)}else{result.set(bytes,0)}return hexlify(result)}function zeroPadValue(data,length){return zeroPad(data,length,true)}function zeroPadBytes(data,length){return zeroPad(data,length,false)}const BN_0$2=BigInt(0);const BN_1$1=BigInt(1);const maxValue=9007199254740991;function toTwos(_value,_width){let value=getBigInt(_value,"value");const width=BigInt(getNumber(_width,"width"));const limit=BN_1$1<<width-BN_1$1;if(value<BN_0$2){value=-value;assert(value<=limit,"too low","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:_value});const mask=(BN_1$1<<width)-BN_1$1;return(~value&mask)+BN_1$1}else{assert(value<limit,"too high","NUMERIC_FAULT",{operation:"toTwos",fault:"overflow",value:_value})}return value}function getBigInt(value,name){switch(typeof value){case"bigint":return value;case"number":assertArgument(Number.isInteger(value),"underflow",name||"value",value);assertArgument(value>=-maxValue&&value<=maxValue,"overflow",name||"value",value);return BigInt(value);case"string":try{if(value===""){throw new Error("empty string")}if(value[0]==="-"&&value[1]!=="-"){return-BigInt(value.substring(1))}return BigInt(value)}catch(e){assertArgument(false,`invalid BigNumberish string: ${e.message}`,name||"value",value)}}assertArgument(false,"invalid BigNumberish value",name||"value",value)}function getUint(value,name){const result=getBigInt(value,name);assert(result>=BN_0$2,"unsigned value cannot be negative","NUMERIC_FAULT",{fault:"overflow",operation:"getUint",value:value});return result}function getNumber(value,name){switch(typeof value){case"bigint":assertArgument(value>=-maxValue&&value<=maxValue,"overflow",name||"value",value);return Number(value);case"number":assertArgument(Number.isInteger(value),"underflow",name||"value",value);assertArgument(value>=-maxValue&&value<=maxValue,"overflow",name||"value",value);return value;case"string":try{if(value===""){throw new Error("empty string")}return getNumber(BigInt(value),name)}catch(e){assertArgument(false,`invalid numeric string: ${e.message}`,name||"value",value)}}assertArgument(false,"invalid numeric value",name||"value",value)}function toBeHex(_value,_width){const value=getUint(_value,"value");let result=value.toString(16);if(_width==null){if(result.length%2){result="0"+result}}else{const width=getNumber(_width,"width");assert(width*2>=result.length,`value exceeds width (${width} bytes)`,"NUMERIC_FAULT",{operation:"toBeHex",fault:"overflow",value:_value});while(result.length<width*2){result="0"+result}}return"0x"+result}function toBeArray(_value){const value=getUint(_value,"value");if(value===BN_0$2){return new Uint8Array([])}let hex=value.toString(16);if(hex.length%2){hex="0"+hex}const result=new Uint8Array(hex.length/2);for(let i=0;i<result.length;i++){const offset=i*2;result[i]=parseInt(hex.substring(offset,offset+2),16)}return result}function toUtf8Bytes(str,form){assertArgument(typeof str==="string","invalid string value","str",str);if(form!=null){assertNormalize(form);str=str.normalize(form)}let result=[];for(let i=0;i<str.length;i++){const c=str.charCodeAt(i);if(c<128){result.push(c)}else if(c<2048){result.push(c>>6|192);result.push(c&63|128)}else if((c&64512)==55296){i++;const c2=str.charCodeAt(i);assertArgument(i<str.length&&(c2&64512)===56320,"invalid surrogate pair","str",str);const pair=65536+((c&1023)<<10)+(c2&1023);result.push(pair>>18|240);result.push(pair>>12&63|128);result.push(pair>>6&63|128);result.push(pair&63|128)}else{result.push(c>>12|224);result.push(c>>6&63|128);result.push(c&63|128)}}return new Uint8Array(result)}function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`Wrong positive integer: ${n}`)}function bytes(b,...lengths){if(!(b instanceof Uint8Array))throw new Error("Expected Uint8Array");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`)}function hash(hash){if(typeof hash!=="function"||typeof hash.create!=="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number(hash.outputLen);number(hash.blockLen)}function exists(instance,checkFinished=true){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min){throw new Error(`digestInto() expects output buffer of length at least ${min}`)}}const crypto$1=typeof globalThis==="object"&&"crypto"in globalThis?globalThis.crypto:undefined;const u8a$1=a=>a instanceof Uint8Array;const u32=arr=>new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4));const createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength);const rotr=(word,shift)=>word<<32-shift|word>>>shift;const isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$1(str){if(typeof str!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function toBytes(data){if(typeof data==="string")data=utf8ToBytes$1(data);if(!u8a$1(data))throw new Error(`expected Uint8Array, got ${typeof data}`);return data}function concatBytes$1(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!u8a$1(a))throw new Error("Uint8Array expected");r.set(a,pad);pad+=a.length});return r}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest();const tmp=hashCons();hashC.outputLen=tmp.outputLen;hashC.blockLen=tmp.blockLen;hashC.create=()=>hashCons();return hashC}function randomBytes(bytesLength=32){if(crypto$1&&typeof crypto$1.getRandomValues==="function"){return crypto$1.getRandomValues(new Uint8Array(bytesLength))}throw new Error("crypto.getRandomValues must be defined")}class HMAC extends Hash{constructor(hash$1,_key){super();this.finished=false;this.destroyed=false;hash(hash$1);const key=toBytes(_key);this.iHash=hash$1.create();if(typeof this.iHash.update!=="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen;this.outputLen=this.iHash.outputLen;const blockLen=this.blockLen;const pad=new Uint8Array(blockLen);pad.set(key.length>blockLen?hash$1.create().update(key).digest():key);for(let i=0;i<pad.length;i++)pad[i]^=54;this.iHash.update(pad);this.oHash=hash$1.create();for(let i=0;i<pad.length;i++)pad[i]^=54^92;this.oHash.update(pad);pad.fill(0)}update(buf){exists(this);this.iHash.update(buf);return this}digestInto(out){exists(this);bytes(out,this.outputLen);this.finished=true;this.iHash.digestInto(out);this.oHash.update(out);this.oHash.digestInto(out);this.destroy()}digest(){const out=new Uint8Array(this.oHash.outputLen);this.digestInto(out);return out}_cloneInto(to){to||(to=Object.create(Object.getPrototypeOf(this),{}));const{oHash,iHash,finished,destroyed,blockLen,outputLen}=this;to=to;to.finished=finished;to.destroyed=destroyed;to.blockLen=blockLen;to.outputLen=outputLen;to.oHash=oHash._cloneInto(to.oHash);to.iHash=iHash._cloneInto(to.iHash);return to}destroy(){this.destroyed=true;this.oHash.destroy();this.iHash.destroy()}}const hmac=(hash,key,message)=>new HMAC(hash,key).update(message).digest();hmac.create=(hash,key)=>new HMAC(hash,key);function setBigUint64(view,byteOffset,value,isLE){if(typeof view.setBigUint64==="function")return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32);const _u32_max=BigInt(4294967295);const wh=Number(value>>_32n&_u32_max);const wl=Number(value&_u32_max);const h=isLE?4:0;const l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE);view.setUint32(byteOffset+l,wl,isLE)}class SHA2 extends Hash{constructor(blockLen,outputLen,padOffset,isLE){super();this.blockLen=blockLen;this.outputLen=outputLen;this.padOffset=padOffset;this.isLE=isLE;this.finished=false;this.length=0;this.pos=0;this.destroyed=false;this.buffer=new Uint8Array(blockLen);this.view=createView(this.buffer)}update(data){exists(this);const{view,buffer,blockLen}=this;data=toBytes(data);const len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take===blockLen){const dataView=createView(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos);continue}buffer.set(data.subarray(pos,pos+take),this.pos);this.pos+=take;pos+=take;if(this.pos===blockLen){this.process(view,0);this.pos=0}}this.length+=data.length;this.roundClean();return this}digestInto(out){exists(this);output(out,this);this.finished=true;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128;this.buffer.subarray(pos).fill(0);if(this.padOffset>blockLen-pos){this.process(view,0);pos=0}for(let i=pos;i<blockLen;i++)buffer[i]=0;setBigUint64(view,blockLen-8,BigInt(this.length*8),isLE);this.process(view,0);const oview=createView(out);const len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4;const state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);this.destroy();return res}_cloneInto(to){to||(to=new this.constructor);to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;to.length=length;to.pos=pos;to.finished=finished;to.destroyed=destroyed;if(length%blockLen)to.buffer.set(buffer);return to}}const Chi=(a,b,c)=>a&b^~a&c;const Maj=(a,b,c)=>a&b^a&c^b&c;const SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]);const IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]);const SHA256_W=new Uint32Array(64);class SHA256 extends SHA2{constructor(){super(64,32,8,false);this.A=IV[0]|0;this.B=IV[1]|0;this.C=IV[2]|0;this.D=IV[3]|0;this.E=IV[4]|0;this.F=IV[5]|0;this.G=IV[6]|0;this.H=IV[7]|0}get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=A|0;this.B=B|0;this.C=C|0;this.D=D|0;this.E=E|0;this.F=F|0;this.G=G|0;this.H=H|0}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,false);for(let i=16;i<64;i++){const W15=SHA256_W[i-15];const W2=SHA256_W[i-2];const s0=rotr(W15,7)^rotr(W15,18)^W15>>>3;const s1=rotr(W2,17)^rotr(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const sigma1=rotr(E,6)^rotr(E,11)^rotr(E,25);const T1=H+sigma1+Chi(E,F,G)+SHA256_K[i]+SHA256_W[i]|0;const sigma0=rotr(A,2)^rotr(A,13)^rotr(A,22);const T2=sigma0+Maj(A,B,C)|0;H=G;G=F;F=E;E=D+T1|0;D=C;C=B;B=A;A=T1+T2|0}A=A+this.A|0;B=B+this.B|0;C=C+this.C|0;D=D+this.D|0;E=E+this.E|0;F=F+this.F|0;G=G+this.G|0;H=H+this.H|0;this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0);this.buffer.fill(0)}}const sha256=wrapConstructor(()=>new SHA256);const U32_MASK64=BigInt(2**32-1);const _32n=BigInt(32);function fromBig(n,le=false){if(le)return{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)};return{h:Number(n>>_32n&U32_MASK64)|0,l:Number(n&U32_MASK64)|0}}function split(lst,le=false){let Ah=new Uint32Array(lst.length);let Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const rotlSH=(h,l,s)=>h<<s|l>>>32-s;const rotlSL=(h,l,s)=>l<<s|h>>>32-s;const rotlBH=(h,l,s)=>l<<s-32|h>>>64-s;const rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;const[SHA3_PI,SHA3_ROTL,_SHA3_IOTA]=[[],[],[]];const _0n$4=BigInt(0);const _1n$5=BigInt(1);const _2n$3=BigInt(2);const _7n=BigInt(7);const _256n=BigInt(256);const _0x71n=BigInt(113);for(let round=0,R=_1n$5,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5];SHA3_PI.push(2*(5*y+x));SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n$4;for(let j=0;j<7;j++){R=(R<<_1n$5^(R>>_7n)*_0x71n)%_256n;if(R&_2n$3)t^=_1n$5<<(_1n$5<<BigInt(j))-_1n$5}_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=split(_SHA3_IOTA,true);const rotlH=(h,l,s)=>s>32?rotlBH(h,l,s):rotlSH(h,l,s);const rotlL=(h,l,s)=>s>32?rotlBL(h,l,s):rotlSL(h,l,s);function keccakP(s,rounds=24){const B=new Uint32Array(5*2);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10;const idx0=(x+2)%10;const B0=B[idx0];const B1=B[idx0+1];const Th=rotlH(B0,B1,1)^B[idx1];const Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10){s[x+y]^=Th;s[x+y+1]^=Tl}}let curH=s[2];let curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t];const Th=rotlH(curH,curL,shift);const Tl=rotlL(curH,curL,shift);const PI=SHA3_PI[t];curH=s[PI];curL=s[PI+1];s[PI]=Th;s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round];s[1]^=SHA3_IOTA_L[round]}B.fill(0)}class Keccak extends Hash{constructor(blockLen,suffix,outputLen,enableXOF=false,rounds=24){super();this.blockLen=blockLen;this.suffix=suffix;this.outputLen=outputLen;this.enableXOF=enableXOF;this.rounds=rounds;this.pos=0;this.posOut=0;this.finished=false;this.destroyed=false;number(outputLen);if(0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");this.state=new Uint8Array(200);this.state32=u32(this.state)}keccak(){keccakP(this.state32,this.rounds);this.posOut=0;this.pos=0}update(data){exists(this);const{blockLen,state}=this;data=toBytes(data);const len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];if(this.pos===blockLen)this.keccak()}return this}finish(){if(this.finished)return;this.finished=true;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix;if((suffix&128)!==0&&pos===blockLen-1)this.keccak();state[blockLen-1]^=128;this.keccak()}writeInto(out){exists(this,false);bytes(out);this.finish();const bufferOut=this.state;const{blockLen}=this;for(let pos=0,len=out.length;pos<len;){if(this.posOut>=blockLen)this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos);this.posOut+=take;pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){number(bytes);return this.xofInto(new Uint8Array(bytes))}digestInto(out){output(out,this);if(this.finished)throw new Error("digest() was already called");this.writeInto(out);this.destroy();return out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=true;this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds));to.state32.set(this.state32);to.pos=this.pos;to.posOut=this.posOut;to.finished=this.finished;to.rounds=rounds;to.suffix=suffix;to.outputLen=outputLen;to.enableXOF=enableXOF;to.destroyed=this.destroyed;return to}}const gen=(suffix,blockLen,outputLen)=>wrapConstructor(()=>new Keccak(blockLen,suffix,outputLen));const keccak_256=gen(1,136,256/8);let locked=false;const _keccak256=function(data){return keccak_256(data)};let __keccak256=_keccak256;function keccak256(_data){const data=getBytes(_data,"data");return hexlify(__keccak256(data))}keccak256._=_keccak256;keccak256.lock=function(){locked=true};keccak256.register=function(func){if(locked){throw new TypeError("keccak256 is locked")}__keccak256=func};Object.freeze(keccak256);const _0n$3=BigInt(0);const _1n$4=BigInt(1);const _2n$2=BigInt(2);const u8a=a=>a instanceof Uint8Array;const hexes=Array.from({length:256},(_,i)=>i.toString(16).padStart(2,"0"));function bytesToHex(bytes){if(!u8a(bytes))throw new Error("Uint8Array expected");let hex="";for(let i=0;i<bytes.length;i++){hex+=hexes[bytes[i]]}return hex}function numberToHexUnpadded(num){const hex=num.toString(16);return hex.length&1?`0${hex}`:hex}function hexToNumber(hex){if(typeof hex!=="string")throw new Error("hex string expected, got "+typeof hex);return BigInt(hex===""?"0":`0x${hex}`)}function hexToBytes(hex){if(typeof hex!=="string")throw new Error("hex string expected, got "+typeof hex);const len=hex.length;if(len%2)throw new Error("padded hex string expected, got unpadded hex of length "+len);const array=new Uint8Array(len/2);for(let i=0;i<array.length;i++){const j=i*2;const hexByte=hex.slice(j,j+2);const byte=Number.parseInt(hexByte,16);if(Number.isNaN(byte)||byte<0)throw new Error("Invalid byte sequence");array[i]=byte}return array}function bytesToNumberBE(bytes){return hexToNumber(bytesToHex(bytes))}function bytesToNumberLE(bytes){if(!u8a(bytes))throw new Error("Uint8Array expected");return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()))}function numberToBytesBE(n,len){return hexToBytes(n.toString(16).padStart(len*2,"0"))}function numberToBytesLE(n,len){return numberToBytesBE(n,len).reverse()}function numberToVarBytesBE(n){return hexToBytes(numberToHexUnpadded(n))}function ensureBytes(title,hex,expectedLength){let res;if(typeof hex==="string"){try{res=hexToBytes(hex)}catch(e){throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`)}}else if(u8a(hex)){res=Uint8Array.from(hex)}else{throw new Error(`${title} must be hex string or Uint8Array`)}const len=res.length;if(typeof expectedLength==="number"&&len!==expectedLength)throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);return res}function concatBytes(...arrays){const r=new Uint8Array(arrays.reduce((sum,a)=>sum+a.length,0));let pad=0;arrays.forEach(a=>{if(!u8a(a))throw new Error("Uint8Array expected");r.set(a,pad);pad+=a.length});return r}function equalBytes(b1,b2){if(b1.length!==b2.length)return false;for(let i=0;i<b1.length;i++)if(b1[i]!==b2[i])return false;return true}function utf8ToBytes(str){if(typeof str!=="string")throw new Error(`utf8ToBytes expected string, got ${typeof str}`);return new Uint8Array((new TextEncoder).encode(str))}function bitLen(n){let len;for(len=0;n>_0n$3;n>>=_1n$4,len+=1);return len}function bitGet(n,pos){return n>>BigInt(pos)&_1n$4}const bitSet=(n,pos,value)=>{return n|(value?_1n$4:_0n$3)<<BigInt(pos)};const bitMask=n=>(_2n$2<<BigInt(n-1))-_1n$4;const u8n=data=>new Uint8Array(data);const u8fr=arr=>Uint8Array.from(arr);function createHmacDrbg(hashLen,qByteLen,hmacFn){if(typeof hashLen!=="number"||hashLen<2)throw new Error("hashLen must be a number");if(typeof qByteLen!=="number"||qByteLen<2)throw new Error("qByteLen must be a number");if(typeof hmacFn!=="function")throw new Error("hmacFn must be a function");let v=u8n(hashLen);let k=u8n(hashLen);let i=0;const reset=()=>{v.fill(1);k.fill(0);i=0};const h=(...b)=>hmacFn(k,v,...b);const reseed=(seed=u8n())=>{k=h(u8fr([0]),seed);v=h();if(seed.length===0)return;k=h(u8fr([1]),seed);v=h()};const gen=()=>{if(i++>=1e3)throw new Error("drbg: tried 1000 values");let len=0;const out=[];while(len<qByteLen){v=h();const sl=v.slice();out.push(sl);len+=v.length}return concatBytes(...out)};const genUntil=(seed,pred)=>{reset();reseed(seed);let res=undefined;while(!(res=pred(gen())))reseed();reset();return res};return genUntil}const validatorFns={bigint:val=>typeof val==="bigint",function:val=>typeof val==="function",boolean:val=>typeof val==="boolean",string:val=>typeof val==="string",stringOrUint8Array:val=>typeof val==="string"||val instanceof Uint8Array,isSafeInteger:val=>Number.isSafeInteger(val),array:val=>Array.isArray(val),field:(val,object)=>object.Fp.isValid(val),hash:val=>typeof val==="function"&&Number.isSafeInteger(val.outputLen)};function validateObject(object,validators,optValidators={}){const checkField=(fieldName,type,isOptional)=>{const checkVal=validatorFns[type];if(typeof checkVal!=="function")throw new Error(`Invalid validator "${type}", expected function`);const val=object[fieldName];if(isOptional&&val===undefined)return;if(!checkVal(val,object)){throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`)}};for(const[fieldName,type]of Object.entries(validators))checkField(fieldName,type,false);for(const[fieldName,type]of Object.entries(optValidators))checkField(fieldName,type,true);return object}var ut=Object.freeze({__proto__:null,bitGet:bitGet,bitLen:bitLen,bitMask:bitMask,bitSet:bitSet,bytesToHex:bytesToHex,bytesToNumberBE:bytesToNumberBE,bytesToNumberLE:bytesToNumberLE,concatBytes:concatBytes,createHmacDrbg:createHmacDrbg,ensureBytes:ensureBytes,equalBytes:equalBytes,hexToBytes:hexToBytes,hexToNumber:hexToNumber,numberToBytesBE:numberToBytesBE,numberToBytesLE:numberToBytesLE,numberToHexUnpadded:numberToHexUnpadded,numberToVarBytesBE:numberToVarBytesBE,utf8ToBytes:utf8ToBytes,validateObject:validateObject});const _0n$2=BigInt(0),_1n$3=BigInt(1),_2n$1=BigInt(2),_3n$1=BigInt(3);const _4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);BigInt(9);BigInt(16);function mod(a,b){const result=a%b;return result>=_0n$2?result:b+result}function pow(num,power,modulo){if(modulo<=_0n$2||power<_0n$2)throw new Error("Expected power/modulo > 0");if(modulo===_1n$3)return _0n$2;let res=_1n$3;while(power>_0n$2){if(power&_1n$3)res=res*num%modulo;num=num*num%modulo;power>>=_1n$3}return res}function pow2(x,power,modulo){let res=x;while(power-- >_0n$2){res*=res;res%=modulo}return res}function invert(number,modulo){if(number===_0n$2||modulo<=_0n$2){throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`)}let a=mod(number,modulo);let b=modulo;let x=_0n$2,u=_1n$3;while(a!==_0n$2){const q=b/a;const r=b%a;const m=x-u*q;b=a,a=r,x=u,u=m}const gcd=b;if(gcd!==_1n$3)throw new Error("invert: does not exist");return mod(x,modulo)}function tonelliShanks(P){const legendreC=(P-_1n$3)/_2n$1;let Q,S,Z;for(Q=P-_1n$3,S=0;Q%_2n$1===_0n$2;Q/=_2n$1,S++);for(Z=_2n$1;Z<P&&pow(Z,legendreC,P)!==P-_1n$3;Z++);if(S===1){const p1div4=(P+_1n$3)/_4n;return function tonelliFast(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}const Q1div2=(Q+_1n$3)/_2n$1;return function tonelliSlow(Fp,n){if(Fp.pow(n,legendreC)===Fp.neg(Fp.ONE))throw new Error("Cannot find square root");let r=S;let g=Fp.pow(Fp.mul(Fp.ONE,Z),Q);let x=Fp.pow(n,Q1div2);let b=Fp.pow(n,Q);while(!Fp.eql(b,Fp.ONE)){if(Fp.eql(b,Fp.ZERO))return Fp.ZERO;let m=1;for(let t2=Fp.sqr(b);m<r;m++){if(Fp.eql(t2,Fp.ONE))break;t2=Fp.sqr(t2)}const ge=Fp.pow(g,_1n$3<<BigInt(r-m-1));g=Fp.sqr(ge);x=Fp.mul(x,ge);b=Fp.mul(b,g);r=m}return x}}function FpSqrt(P){if(P%_4n===_3n$1){const p1div4=(P+_1n$3)/_4n;return function sqrt3mod4(Fp,n){const root=Fp.pow(n,p1div4);if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}if(P%_8n===_5n){const c1=(P-_5n)/_8n;return function sqrt5mod8(Fp,n){const n2=Fp.mul(n,_2n$1);const v=Fp.pow(n2,c1);const nv=Fp.mul(n,v);const i=Fp.mul(Fp.mul(nv,_2n$1),v);const root=Fp.mul(nv,Fp.sub(i,Fp.ONE));if(!Fp.eql(Fp.sqr(root),n))throw new Error("Cannot find square root");return root}}return tonelliShanks(P)}const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(field){const initial={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"};const opts=FIELD_FIELDS.reduce((map,val)=>{map[val]="function";return map},initial);return validateObject(field,opts)}function FpPow(f,num,power){if(power<_0n$2)throw new Error("Expected power > 0");if(power===_0n$2)return f.ONE;if(power===_1n$3)return num;let p=f.ONE;let d=num;while(power>_0n$2){if(power&_1n$3)p=f.mul(p,d);d=f.sqr(d);power>>=_1n$3}return p}function FpInvertBatch(f,nums){const tmp=new Array(nums.length);const lastMultiplied=nums.reduce((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=acc;return f.mul(acc,num)},f.ONE);const inverted=f.inv(lastMultiplied);nums.reduceRight((acc,num,i)=>{if(f.is0(num))return acc;tmp[i]=f.mul(acc,tmp[i]);return f.mul(acc,num)},inverted);return tmp}function nLength(n,nBitLength){const _nBitLength=nBitLength!==undefined?nBitLength:n.toString(2).length;const nByteLength=Math.ceil(_nBitLength/8);return{nBitLength:_nBitLength,nByteLength:nByteLength}}function Field(ORDER,bitLen,isLE=false,redef={}){if(ORDER<=_0n$2)throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);const{nBitLength:BITS,nByteLength:BYTES}=nLength(ORDER,bitLen);if(BYTES>2048)throw new Error("Field lengths over 2048 bytes are not supported");const sqrtP=FpSqrt(ORDER);const f=Object.freeze({ORDER:ORDER,BITS:BITS,BYTES:BYTES,MASK:bitMask(BITS),ZERO:_0n$2,ONE:_1n$3,create:num=>mod(num,ORDER),isValid:num=>{if(typeof num!=="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);return _0n$2<=num&&num<ORDER},is0:num=>num===_0n$2,isOdd:num=>(num&_1n$3)===_1n$3,neg:num=>mod(-num,ORDER),eql:(lhs,rhs)=>lhs===rhs,sqr:num=>mod(num*num,ORDER),add:(lhs,rhs)=>mod(lhs+rhs,ORDER),sub:(lhs,rhs)=>mod(lhs-rhs,ORDER),mul:(lhs,rhs)=>mod(lhs*rhs,ORDER),pow:(num,power)=>FpPow(f,num,power),div:(lhs,rhs)=>mod(lhs*invert(rhs,ORDER),ORDER),sqrN:num=>num*num,addN:(lhs,rhs)=>lhs+rhs,subN:(lhs,rhs)=>lhs-rhs,mulN:(lhs,rhs)=>lhs*rhs,inv:num=>invert(num,ORDER),sqrt:redef.sqrt||(n=>sqrtP(f,n)),invertBatch:lst=>FpInvertBatch(f,lst),cmov:(a,b,c)=>c?b:a,toBytes:num=>isLE?numberToBytesLE(num,BYTES):numberToBytesBE(num,BYTES),fromBytes:bytes=>{if(bytes.length!==BYTES)throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);return isLE?bytesToNumberLE(bytes):bytesToNumberBE(bytes)}});return Object.freeze(f)}function getFieldBytesLength(fieldOrder){if(typeof fieldOrder!=="bigint")throw new Error("field order must be bigint");const bitLength=fieldOrder.toString(2).length;return Math.ceil(bitLength/8)}function getMinHashLength(fieldOrder){const length=getFieldBytesLength(fieldOrder);return length+Math.ceil(length/2)}function mapHashToField(key,fieldOrder,isLE=false){const len=key.length;const fieldLen=getFieldBytesLength(fieldOrder);const minLen=getMinHashLength(fieldOrder);if(len<16||len<minLen||len>1024)throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);const num=isLE?bytesToNumberBE(key):bytesToNumberLE(key);const reduced=mod(num,fieldOrder-_1n$3)+_1n$3;return isLE?numberToBytesLE(reduced,fieldLen):numberToBytesBE(reduced,fieldLen)}const _0n$1=BigInt(0);const _1n$2=BigInt(1);function wNAF(c,bits){const constTimeNegate=(condition,item)=>{const neg=item.negate();return condition?neg:item};const opts=W=>{const windows=Math.ceil(bits/W)+1;const windowSize=2**(W-1);return{windows:windows,windowSize:windowSize}};return{constTimeNegate:constTimeNegate,unsafeLadder(elm,n){let p=c.ZERO;let d=elm;while(n>_0n$1){if(n&_1n$2)p=p.add(d);d=d.double();n>>=_1n$2}return p},precomputeWindow(elm,W){const{windows,windowSize}=opts(W);const points=[];let p=elm;let base=p;for(let window=0;window<windows;window++){base=p;points.push(base);for(let i=1;i<windowSize;i++){base=base.add(p);points.push(base)}p=base.double()}return points},wNAF(W,precomputes,n){const{windows,windowSize}=opts(W);let p=c.ZERO;let f=c.BASE;const mask=BigInt(2**W-1);const maxNumber=2**W;const shiftBy=BigInt(W);for(let window=0;window<windows;window++){const offset=window*windowSize;let wbits=Number(n&mask);n>>=shiftBy;if(wbits>windowSize){wbits-=maxNumber;n+=_1n$2}const offset1=offset;const offset2=offset+Math.abs(wbits)-1;const cond1=window%2!==0;const cond2=wbits<0;if(wbits===0){f=f.add(constTimeNegate(cond1,precomputes[offset1]))}else{p=p.add(constTimeNegate(cond2,precomputes[offset2]))}}return{p:p,f:f}},wNAFCached(P,precomputesMap,n,transform){const W=P._WINDOW_SIZE||1;let comp=precomputesMap.get(P);if(!comp){comp=this.precomputeWindow(P,W);if(W!==1){precomputesMap.set(P,transform(comp))}}return this.wNAF(W,comp,n)}}}function validateBasic(curve){validateField(curve.Fp);validateObject(curve,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"});return Object.freeze({...nLength(curve.n,curve.nBitLength),...curve,...{p:curve.Fp.ORDER}})}function validatePointOpts(curve){const opts=validateBasic(curve);validateObject(opts,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo,Fp,a}=opts;if(endo){if(!Fp.eql(a,Fp.ZERO)){throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0")}if(typeof endo!=="object"||typeof endo.beta!=="bigint"||typeof endo.splitScalar!=="function"){throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}}return Object.freeze({...opts})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut;const DER={Err:class DERErr extends Error{constructor(m=""){super(m)}},_parseInt(data){const{Err:E}=DER;if(data.length<2||data[0]!==2)throw new E("Invalid signature integer tag");const len=data[1];const res=data.subarray(2,len+2);if(!len||res.length!==len)throw new E("Invalid signature integer: wrong length");if(res[0]&128)throw new E("Invalid signature integer: negative");if(res[0]===0&&!(res[1]&128))throw new E("Invalid signature integer: unnecessary leading zero");return{d:b2n(res),l:data.subarray(len+2)}},toSig(hex){const{Err:E}=DER;const data=typeof hex==="string"?h2b(hex):hex;if(!(data instanceof Uint8Array))throw new Error("ui8a expected");let l=data.length;if(l<2||data[0]!=48)throw new E("Invalid signature tag");if(data[1]!==l-2)throw new E("Invalid signature: incorrect length");const{d:r,l:sBytes}=DER._parseInt(data.subarray(2));const{d:s,l:rBytesLeft}=DER._parseInt(sBytes);if(rBytesLeft.length)throw new E("Invalid signature: left bytes after parsing");return{r:r,s:s}},hexFromSig(sig){const slice=s=>Number.parseInt(s[0],16)&8?"00"+s:s;const h=num=>{const hex=num.toString(16);return hex.length&1?`0${hex}`:hex};const s=slice(h(sig.s));const r=slice(h(sig.r));const shl=s.length/2;const rhl=r.length/2;const sl=h(shl);const rl=h(rhl);return`30${h(rhl+shl+4)}02${rl}${r}02${sl}${s}`}};const _0n=BigInt(0),_1n$1=BigInt(1);BigInt(2);const _3n=BigInt(3);BigInt(4);function weierstrassPoints(opts){const CURVE=validatePointOpts(opts);const{Fp}=CURVE;const toBytes=CURVE.toBytes||((_c,point,_isCompressed)=>{const a=point.toAffine();return concatBytes(Uint8Array.from([4]),Fp.toBytes(a.x),Fp.toBytes(a.y))});const fromBytes=CURVE.fromBytes||(bytes=>{const tail=bytes.subarray(1);const x=Fp.fromBytes(tail.subarray(0,Fp.BYTES));const y=Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES));return{x:x,y:y}});function weierstrassEquation(x){const{a,b}=CURVE;const x2=Fp.sqr(x);const x3=Fp.mul(x2,x);return Fp.add(Fp.add(x3,Fp.mul(x,a)),b)}if(!Fp.eql(Fp.sqr(CURVE.Gy),weierstrassEquation(CURVE.Gx)))throw new Error("bad generator point: equation left != right");function isWithinCurveOrder(num){return typeof num==="bigint"&&_0n<num&&num<CURVE.n}function assertGE(num){if(!isWithinCurveOrder(num))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function normPrivateKeyToScalar(key){const{allowedPrivateKeyLengths:lengths,nByteLength,wrapPrivateKey,n}=CURVE;if(lengths&&typeof key!=="bigint"){if(key instanceof Uint8Array)key=bytesToHex(key);if(typeof key!=="string"||!lengths.includes(key.length))throw new Error("Invalid key");key=key.padStart(nByteLength*2,"0")}let num;try{num=typeof key==="bigint"?key:bytesToNumberBE(ensureBytes("private key",key,nByteLength))}catch(error){throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`)}if(wrapPrivateKey)num=mod(num,n);assertGE(num);return num}const pointPrecomputes=new Map;function assertPrjPoint(other){if(!(other instanceof Point))throw new Error("ProjectivePoint expected")}class Point{constructor(px,py,pz){this.px=px;this.py=py;this.pz=pz;if(px==null||!Fp.isValid(px))throw new Error("x required");if(py==null||!Fp.isValid(py))throw new Error("y required");if(pz==null||!Fp.isValid(pz))throw new Error("z required")}static fromAffine(p){const{x,y}=p||{};if(!p||!Fp.isValid(x)||!Fp.isValid(y))throw new Error("invalid affine point");if(p instanceof Point)throw new Error("projective point not allowed");const is0=i=>Fp.eql(i,Fp.ZERO);if(is0(x)&&is0(y))return Point.ZERO;return new Point(x,y,Fp.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(points){const toInv=Fp.invertBatch(points.map(p=>p.pz));return points.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)}static fromHex(hex){const P=Point.fromAffine(fromBytes(ensureBytes("pointHex",hex)));P.assertValidity();return P}static fromPrivateKey(privateKey){return Point.BASE.multiply(normPrivateKeyToScalar(privateKey))}_setWindowSize(windowSize){this._WINDOW_SIZE=windowSize;pointPrecomputes.delete(this)}assertValidity(){if(this.is0()){if(CURVE.allowInfinityPoint&&!Fp.is0(this.py))return;throw new Error("bad point: ZERO")}const{x,y}=this.toAffine();if(!Fp.isValid(x)||!Fp.isValid(y))throw new Error("bad point: x or y not FE");const left=Fp.sqr(y);const right=weierstrassEquation(x);if(!Fp.eql(left,right))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y}=this.toAffine();if(Fp.isOdd)return!Fp.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this;const{px:X2,py:Y2,pz:Z2}=other;const U1=Fp.eql(Fp.mul(X1,Z2),Fp.mul(X2,Z1));const U2=Fp.eql(Fp.mul(Y1,Z2),Fp.mul(Y2,Z1));return U1&&U2}negate(){return new Point(this.px,Fp.neg(this.py),this.pz)}double(){const{a,b}=CURVE;const b3=Fp.mul(b,_3n);const{px:X1,py:Y1,pz:Z1}=this;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;let t0=Fp.mul(X1,X1);let t1=Fp.mul(Y1,Y1);let t2=Fp.mul(Z1,Z1);let t3=Fp.mul(X1,Y1);t3=Fp.add(t3,t3);Z3=Fp.mul(X1,Z1);Z3=Fp.add(Z3,Z3);X3=Fp.mul(a,Z3);Y3=Fp.mul(b3,t2);Y3=Fp.add(X3,Y3);X3=Fp.sub(t1,Y3);Y3=Fp.add(t1,Y3);Y3=Fp.mul(X3,Y3);X3=Fp.mul(t3,X3);Z3=Fp.mul(b3,Z3);t2=Fp.mul(a,t2);t3=Fp.sub(t0,t2);t3=Fp.mul(a,t3);t3=Fp.add(t3,Z3);Z3=Fp.add(t0,t0);t0=Fp.add(Z3,t0);t0=Fp.add(t0,t2);t0=Fp.mul(t0,t3);Y3=Fp.add(Y3,t0);t2=Fp.mul(Y1,Z1);t2=Fp.add(t2,t2);t0=Fp.mul(t2,t3);X3=Fp.sub(X3,t0);Z3=Fp.mul(t2,t1);Z3=Fp.add(Z3,Z3);Z3=Fp.add(Z3,Z3);return new Point(X3,Y3,Z3)}add(other){assertPrjPoint(other);const{px:X1,py:Y1,pz:Z1}=this;const{px:X2,py:Y2,pz:Z2}=other;let X3=Fp.ZERO,Y3=Fp.ZERO,Z3=Fp.ZERO;const a=CURVE.a;const b3=Fp.mul(CURVE.b,_3n);let t0=Fp.mul(X1,X2);let t1=Fp.mul(Y1,Y2);let t2=Fp.mul(Z1,Z2);let t3=Fp.add(X1,Y1);let t4=Fp.add(X2,Y2);t3=Fp.mul(t3,t4);t4=Fp.add(t0,t1);t3=Fp.sub(t3,t4);t4=Fp.add(X1,Z1);let t5=Fp.add(X2,Z2);t4=Fp.mul(t4,t5);t5=Fp.add(t0,t2);t4=Fp.sub(t4,t5);t5=Fp.add(Y1,Z1);X3=Fp.add(Y2,Z2);t5=Fp.mul(t5,X3);X3=Fp.add(t1,t2);t5=Fp.sub(t5,X3);Z3=Fp.mul(a,t4);X3=Fp.mul(b3,t2);Z3=Fp.add(X3,Z3);X3=Fp.sub(t1,Z3);Z3=Fp.add(t1,Z3);Y3=Fp.mul(X3,Z3);t1=Fp.add(t0,t0);t1=Fp.add(t1,t0);t2=Fp.mul(a,t2);t4=Fp.mul(b3,t4);t1=Fp.add(t1,t2);t2=Fp.sub(t0,t2);t2=Fp.mul(a,t2);t4=Fp.add(t4,t2);t0=Fp.mul(t1,t4);Y3=Fp.add(Y3,t0);t0=Fp.mul(t5,t4);X3=Fp.mul(t3,X3);X3=Fp.sub(X3,t0);t0=Fp.mul(t3,t1);Z3=Fp.mul(t5,Z3);Z3=Fp.add(Z3,t0);return new Point(X3,Y3,Z3)}subtract(other){return this.add(other.negate())}is0(){return this.equals(Point.ZERO)}wNAF(n){return wnaf.wNAFCached(this,pointPrecomputes,n,comp=>{const toInv=Fp.invertBatch(comp.map(p=>p.pz));return comp.map((p,i)=>p.toAffine(toInv[i])).map(Point.fromAffine)})}multiplyUnsafe(n){const I=Point.ZERO;if(n===_0n)return I;assertGE(n);if(n===_1n$1)return this;const{endo}=CURVE;if(!endo)return wnaf.unsafeLadder(this,n);let{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let k1p=I;let k2p=I;let d=this;while(k1>_0n||k2>_0n){if(k1&_1n$1)k1p=k1p.add(d);if(k2&_1n$1)k2p=k2p.add(d);d=d.double();k1>>=_1n$1;k2>>=_1n$1}if(k1neg)k1p=k1p.negate();if(k2neg)k2p=k2p.negate();k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz);return k1p.add(k2p)}multiply(scalar){assertGE(scalar);let n=scalar;let point,fake;const{endo}=CURVE;if(endo){const{k1neg,k1,k2neg,k2}=endo.splitScalar(n);let{p:k1p,f:f1p}=this.wNAF(k1);let{p:k2p,f:f2p}=this.wNAF(k2);k1p=wnaf.constTimeNegate(k1neg,k1p);k2p=wnaf.constTimeNegate(k2neg,k2p);k2p=new Point(Fp.mul(k2p.px,endo.beta),k2p.py,k2p.pz);point=k1p.add(k2p);fake=f1p.add(f2p)}else{const{p,f}=this.wNAF(n);point=p;fake=f}return Point.normalizeZ([point,fake])[0]}multiplyAndAddUnsafe(Q,a,b){const G=Point.BASE;const mul=(P,a)=>a===_0n||a===_1n$1||!P.equals(G)?P.multiplyUnsafe(a):P.multiply(a);const sum=mul(this,a).add(mul(Q,b));return sum.is0()?undefined:sum}toAffine(iz){const{px:x,py:y,pz:z}=this;const is0=this.is0();if(iz==null)iz=is0?Fp.ONE:Fp.inv(z);const ax=Fp.mul(x,iz);const ay=Fp.mul(y,iz);const zz=Fp.mul(z,iz);if(is0)return{x:Fp.ZERO,y:Fp.ZERO};if(!Fp.eql(zz,Fp.ONE))throw new Error("invZ was invalid");return{x:ax,y:ay}}isTorsionFree(){const{h:cofactor,isTorsionFree}=CURVE;if(cofactor===_1n$1)return true;if(isTorsionFree)return isTorsionFree(Point,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:cofactor,clearCofactor}=CURVE;if(cofactor===_1n$1)return this;if(clearCofactor)return clearCofactor(Point,this);return this.multiplyUnsafe(CURVE.h)}toRawBytes(isCompressed=true){this.assertValidity();return toBytes(Point,this,isCompressed)}toHex(isCompressed=true){return bytesToHex(this.toRawBytes(isCompressed))}}Point.BASE=new Point(CURVE.Gx,CURVE.Gy,Fp.ONE);Point.ZERO=new Point(Fp.ZERO,Fp.ONE,Fp.ZERO);const _bits=CURVE.nBitLength;const wnaf=wNAF(Point,CURVE.endo?Math.ceil(_bits/2):_bits);return{CURVE:CURVE,ProjectivePoint:Point,normPrivateKeyToScalar:normPrivateKeyToScalar,weierstrassEquation:weierstrassEquation,isWithinCurveOrder:isWithinCurveOrder}}function validateOpts(curve){const opts=validateBasic(curve);validateObject(opts,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"});return Object.freeze({lowS:true,...opts})}function weierstrass(curveDef){const CURVE=validateOpts(curveDef);const{Fp,n:CURVE_ORDER}=CURVE;const compressedLen=Fp.BYTES+1;const uncompressedLen=2*Fp.BYTES+1;function isValidFieldElement(num){return _0n<num&&num<Fp.ORDER}function modN(a){return mod(a,CURVE_ORDER)}function invN(a){return invert(a,CURVE_ORDER)}const{ProjectivePoint:Point,normPrivateKeyToScalar,weierstrassEquation,isWithinCurveOrder}=weierstrassPoints({...CURVE,toBytes(_c,point,isCompressed){const a=point.toAffine();const x=Fp.toBytes(a.x);const cat=concatBytes;if(isCompressed){return cat(Uint8Array.from([point.hasEvenY()?2:3]),x)}else{return cat(Uint8Array.from([4]),x,Fp.toBytes(a.y))}},fromBytes(bytes){const len=bytes.length;const head=bytes[0];const tail=bytes.subarray(1);if(len===compressedLen&&(head===2||head===3)){const x=bytesToNumberBE(tail);if(!isValidFieldElement(x))throw new Error("Point is not on curve");const y2=weierstrassEquation(x);let y=Fp.sqrt(y2);const isYOdd=(y&_1n$1)===_1n$1;const isHeadOdd=(head&1)===1;if(isHeadOdd!==isYOdd)y=Fp.neg(y);return{x:x,y:y}}else if(len===uncompressedLen&&head===4){const x=Fp.fromBytes(tail.subarray(0,Fp.BYTES));const y=Fp.fromBytes(tail.subarray(Fp.BYTES,2*Fp.BYTES));return{x:x,y:y}}else{throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`)}}});const numToNByteStr=num=>bytesToHex(numberToBytesBE(num,CURVE.nByteLength));function isBiggerThanHalfOrder(number){const HALF=CURVE_ORDER>>_1n$1;return number>HALF}function normalizeS(s){return isBiggerThanHalfOrder(s)?modN(-s):s}const slcNum=(b,from,to)=>bytesToNumberBE(b.slice(from,to));class Signature{constructor(r,s,recovery){this.r=r;this.s=s;this.recovery=recovery;this.assertValidity()}static fromCompact(hex){const l=CURVE.nByteLength;hex=ensureBytes("compactSignature",hex,l*2);return new Signature(slcNum(hex,0,l),slcNum(hex,l,2*l))}static fromDER(hex){const{r,s}=DER.toSig(ensureBytes("DER",hex));return new Signature(r,s)}assertValidity(){if(!isWithinCurveOrder(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!isWithinCurveOrder(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(recovery){return new Signature(this.r,this.s,recovery)}recoverPublicKey(msgHash){const{r,s,recovery:rec}=this;const h=bits2int_modN(ensureBytes("msgHash",msgHash));if(rec==null||![0,1,2,3].includes(rec))throw new Error("recovery id invalid");const radj=rec===2||rec===3?r+CURVE.n:r;if(radj>=Fp.ORDER)throw new Error("recovery id 2 or 3 invalid");const prefix=(rec&1)===0?"02":"03";const R=Point.fromHex(prefix+numToNByteStr(radj));const ir=invN(radj);const u1=modN(-h*ir);const u2=modN(s*ir);const Q=Point.BASE.multiplyAndAddUnsafe(R,u1,u2);if(!Q)throw new Error("point at infinify");Q.assertValidity();return Q}hasHighS(){return isBiggerThanHalfOrder(this.s)}normalizeS(){return this.hasHighS()?new Signature(this.r,modN(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return numToNByteStr(this.r)+numToNByteStr(this.s)}}const utils={isValidPrivateKey(privateKey){try{normPrivateKeyToScalar(privateKey);return true}catch(error){return false}},normPrivateKeyToScalar:normPrivateKeyToScalar,randomPrivateKey:()=>{const length=getMinHashLength(CURVE.n);return mapHashToField(CURVE.randomBytes(length),CURVE.n)},precompute(windowSize=8,point=Point.BASE){point._setWindowSize(windowSize);point.multiply(BigInt(3));return point}};function getPublicKey(privateKey,isCompressed=true){return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed)}function isProbPub(item){const arr=item instanceof Uint8Array;const str=typeof item==="string";const len=(arr||str)&&item.length;if(arr)return len===compressedLen||len===uncompressedLen;if(str)return len===2*compressedLen||len===2*uncompressedLen;if(item instanceof Point)return true;return false}function getSharedSecret(privateA,publicB,isCompressed=true){if(isProbPub(privateA))throw new Error("first arg must be private key");if(!isProbPub(publicB))throw new Error("second arg must be public key");const b=Point.fromHex(publicB);return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed)}const bits2int=CURVE.bits2int||function(bytes){const num=bytesToNumberBE(bytes);const delta=bytes.length*8-CURVE.nBitLength;return delta>0?num>>BigInt(delta):num};const bits2int_modN=CURVE.bits2int_modN||function(bytes){return modN(bits2int(bytes))};const ORDER_MASK=bitMask(CURVE.nBitLength);function int2octets(num){if(typeof num!=="bigint")throw new Error("bigint expected");if(!(_0n<=num&&num<ORDER_MASK))throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);return numberToBytesBE(num,CURVE.nByteLength)}function prepSig(msgHash,privateKey,opts=defaultSigOpts){if(["recovered","canonical"].some(k=>k in opts))throw new Error("sign() legacy options not supported");const{hash,randomBytes}=CURVE;let{lowS,prehash,extraEntropy:ent}=opts;if(lowS==null)lowS=true;msgHash=ensureBytes("msgHash",msgHash);if(prehash)msgHash=ensureBytes("prehashed msgHash",hash(msgHash));const h1int=bits2int_modN(msgHash);const d=normPrivateKeyToScalar(privateKey);const seedArgs=[int2octets(d),int2octets(h1int)];if(ent!=null){const e=ent===true?randomBytes(Fp.BYTES):ent;seedArgs.push(ensureBytes("extraEntropy",e))}const seed=concatBytes(...seedArgs);const m=h1int;function k2sig(kBytes){const k=bits2int(kBytes);if(!isWithinCurveOrder(k))return;const ik=invN(k);const q=Point.BASE.multiply(k).toAffine();const r=modN(q.x);if(r===_0n)return;const s=modN(ik*modN(m+r*d));if(s===_0n)return;let recovery=(q.x===r?0:2)|Number(q.y&_1n$1);let normS=s;if(lowS&&isBiggerThanHalfOrder(s)){normS=normalizeS(s);recovery^=1}return new Signature(r,normS,recovery)}return{seed:seed,k2sig:k2sig}}const defaultSigOpts={lowS:CURVE.lowS,prehash:false};const defaultVerOpts={lowS:CURVE.lowS,prehash:false};function sign(msgHash,privKey,opts=defaultSigOpts){const{seed,k2sig}=prepSig(msgHash,privKey,opts);const C=CURVE;const drbg=createHmacDrbg(C.hash.outputLen,C.nByteLength,C.hmac);return drbg(seed,k2sig)}Point.BASE._setWindowSize(8);function verify(signature,msgHash,publicKey,opts=defaultVerOpts){const sg=signature;msgHash=ensureBytes("msgHash",msgHash);publicKey=ensureBytes("publicKey",publicKey);if("strict"in opts)throw new Error("options.strict was renamed to lowS");const{lowS,prehash}=opts;let _sig=undefined;let P;try{if(typeof sg==="string"||sg instanceof Uint8Array){try{_sig=Signature.fromDER(sg)}catch(derError){if(!(derError instanceof DER.Err))throw derError;_sig=Signature.fromCompact(sg)}}else if(typeof sg==="object"&&typeof sg.r==="bigint"&&typeof sg.s==="bigint"){const{r,s}=sg;_sig=new Signature(r,s)}else{throw new Error("PARSE")}P=Point.fromHex(publicKey)}catch(error){if(error.message==="PARSE")throw new Error(`signature must be Signature instance, Uint8Array or hex string`);return false}if(lowS&&_sig.hasHighS())return false;if(prehash)msgHash=CURVE.hash(msgHash);const{r,s}=_sig;const h=bits2int_modN(msgHash);const is=invN(s);const u1=modN(h*is);const u2=modN(r*is);const R=Point.BASE.multiplyAndAddUnsafe(P,u1,u2)?.toAffine();if(!R)return false;const v=modN(R.x);return v===r}return{CURVE:CURVE,getPublicKey:getPublicKey,getSharedSecret:getSharedSecret,sign:sign,verify:verify,ProjectivePoint:Point,Signature:Signature,utils:utils}}function getHash(hash){return{hash:hash,hmac:(key,...msgs)=>hmac(hash,key,concatBytes$1(...msgs)),randomBytes:randomBytes}}function createCurve(curveDef,defHash){const create=hash=>weierstrass({...curveDef,...getHash(hash)});return Object.freeze({...create(defHash),create:create})}const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");const secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");const _1n=BigInt(1);const _2n=BigInt(2);const divNearest=(a,b)=>(a+b/_2n)/b;function sqrtMod(y){const P=secp256k1P;const _3n=BigInt(3),_6n=BigInt(6),_11n=BigInt(11),_22n=BigInt(22);const _23n=BigInt(23),_44n=BigInt(44),_88n=BigInt(88);const b2=y*y*y%P;const b3=b2*b2*y%P;const b6=pow2(b3,_3n,P)*b3%P;const b9=pow2(b6,_3n,P)*b3%P;const b11=pow2(b9,_2n,P)*b2%P;const b22=pow2(b11,_11n,P)*b11%P;const b44=pow2(b22,_22n,P)*b22%P;const b88=pow2(b44,_44n,P)*b44%P;const b176=pow2(b88,_88n,P)*b88%P;const b220=pow2(b176,_44n,P)*b44%P;const b223=pow2(b220,_3n,P)*b3%P;const t1=pow2(b223,_23n,P)*b22%P;const t2=pow2(t1,_6n,P)*b2%P;const root=pow2(t2,_2n,P);if(!Fp.eql(Fp.sqr(root),y))throw new Error("Cannot find square root");return root}const Fp=Field(secp256k1P,undefined,undefined,{sqrt:sqrtMod});const secp256k1=createCurve({a:BigInt(0),b:BigInt(7),Fp:Fp,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:true,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:k=>{const n=secp256k1N;const a1=BigInt("0x3086d221a7d46bcde86c90e49284eb15");const b1=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3");const a2=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");const b2=a1;const POW_2_128=BigInt("0x100000000000000000000000000000000");const c1=divNearest(b2*k,n);const c2=divNearest(-b1*k,n);let k1=mod(k-c1*a1-c2*a2,n);let k2=mod(-c1*b1-c2*b2,n);const k1neg=k1>POW_2_128;const k2neg=k2>POW_2_128;if(k1neg)k1=n-k1;if(k2neg)k2=n-k2;if(k1>POW_2_128||k2>POW_2_128){throw new Error("splitScalar: Endomorphism failed, k="+k)}return{k1neg:k1neg,k1:k1,k2neg:k2neg,k2:k2}}}},sha256);BigInt(0);secp256k1.ProjectivePoint;const ZeroHash="0x0000000000000000000000000000000000000000000000000000000000000000";const BN_0$1=BigInt(0);const BN_1=BigInt(1);const BN_2=BigInt(2);const BN_27=BigInt(27);const BN_28=BigInt(28);const BN_35=BigInt(35);const _guard={};function toUint256(value){return zeroPadValue(toBeArray(value),32)}class Signature{#r;#s;#v;#networkV;get r(){return this.#r}set r(value){assertArgument(dataLength(value)===32,"invalid r","value",value);this.#r=hexlify(value)}get s(){return this.#s}set s(_value){assertArgument(dataLength(_value)===32,"invalid s","value",_value);const value=hexlify(_value);assertArgument(parseInt(value.substring(0,3))<8,"non-canonical s","value",value);this.#s=value}get v(){return this.#v}set v(value){const v=getNumber(value,"value");assertArgument(v===27||v===28,"invalid v","v",value);this.#v=v}get networkV(){return this.#networkV}get legacyChainId(){const v=this.networkV;if(v==null){return null}return Signature.getChainId(v)}get yParity(){return this.v===27?0:1}get yParityAndS(){const yParityAndS=getBytes(this.s);if(this.yParity){yParityAndS[0]|=128}return hexlify(yParityAndS)}get compactSerialized(){return concat([this.r,this.yParityAndS])}get serialized(){return concat([this.r,this.s,this.yParity?"0x1c":"0x1b"])}constructor(guard,r,s,v){assertPrivate(guard,_guard,"Signature");this.#r=r;this.#s=s;this.#v=v;this.#networkV=null}[Symbol.for("nodejs.util.inspect.custom")](){return`Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`}clone(){const clone=new Signature(_guard,this.r,this.s,this.v);if(this.networkV){clone.#networkV=this.networkV}return clone}toJSON(){const networkV=this.networkV;return{_type:"signature",networkV:networkV!=null?networkV.toString():null,r:this.r,s:this.s,v:this.v}}static getChainId(v){const bv=getBigInt(v,"v");if(bv==BN_27||bv==BN_28){return BN_0$1}assertArgument(bv>=BN_35,"invalid EIP-155 v","v",v);return(bv-BN_35)/BN_2}static getChainIdV(chainId,v){return getBigInt(chainId)*BN_2+BigInt(35+v-27)}static getNormalizedV(v){const bv=getBigInt(v);if(bv===BN_0$1||bv===BN_27){return 27}if(bv===BN_1||bv===BN_28){return 28}assertArgument(bv>=BN_35,"invalid v","v",v);return bv&BN_1?27:28}static from(sig){function assertError(check,message){assertArgument(check,message,"signature",sig)}if(sig==null){return new Signature(_guard,ZeroHash,ZeroHash,27)}if(typeof sig==="string"){const bytes=getBytes(sig,"signature");if(bytes.length===64){const r=hexlify(bytes.slice(0,32));const s=bytes.slice(32,64);const v=s[0]&128?28:27;s[0]&=127;return new Signature(_guard,r,hexlify(s),v)}if(bytes.length===65){const r=hexlify(bytes.slice(0,32));const s=bytes.slice(32,64);assertError((s[0]&128)===0,"non-canonical s");const v=Signature.getNormalizedV(bytes[64]);return new Signature(_guard,r,hexlify(s),v)}assertError(false,"invalid raw signature length")}if(sig instanceof Signature){return sig.clone()}const _r=sig.r;assertError(_r!=null,"missing r");const r=toUint256(_r);const s=function(s,yParityAndS){if(s!=null){return toUint256(s)}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),"invalid yParityAndS");const bytes=getBytes(yParityAndS);bytes[0]&=127;return hexlify(bytes)}assertError(false,"missing s")}(sig.s,sig.yParityAndS);assertError((getBytes(s)[0]&128)==0,"non-canonical s");const{networkV,v}=function(_v,yParityAndS,yParity){if(_v!=null){const v=getBigInt(_v);return{networkV:v>=BN_35?v:undefined,v:Signature.getNormalizedV(v)}}if(yParityAndS!=null){assertError(isHexString(yParityAndS,32),"invalid yParityAndS");return{v:getBytes(yParityAndS)[0]&128?28:27}}if(yParity!=null){switch(getNumber(yParity,"sig.yParity")){case 0:return{v:27};case 1:return{v:28}}assertError(false,"invalid yParity")}assertError(false,"missing v")}(sig.v,sig.yParityAndS,sig.yParity);const result=new Signature(_guard,r,s,v);if(networkV){result.#networkV=networkV}assertError(sig.yParity==null||getNumber(sig.yParity,"sig.yParity")===result.yParity,"yParity mismatch");assertError(sig.yParityAndS==null||sig.yParityAndS===result.yParityAndS,"yParityAndS mismatch");return result}}class SigningKey{#privateKey;constructor(privateKey){assertArgument(dataLength(privateKey)===32,"invalid private key","privateKey","[REDACTED]");this.#privateKey=hexlify(privateKey)}get privateKey(){return this.#privateKey}get publicKey(){return SigningKey.computePublicKey(this.#privateKey)}get compressedPublicKey(){return SigningKey.computePublicKey(this.#privateKey,true)}sign(digest){assertArgument(dataLength(digest)===32,"invalid digest length","digest",digest);const sig=secp256k1.sign(getBytesCopy(digest),getBytesCopy(this.#privateKey),{lowS:true});return Signature.from({r:toBeHex(sig.r,32),s:toBeHex(sig.s,32),v:sig.recovery?28:27})}computeSharedSecret(other){const pubKey=SigningKey.computePublicKey(other);return hexlify(secp256k1.getSharedSecret(getBytesCopy(this.#privateKey),getBytes(pubKey),false))}static computePublicKey(key,compressed){let bytes=getBytes(key,"key");if(bytes.length===32){const pubKey=secp256k1.getPublicKey(bytes,!!compressed);return hexlify(pubKey)}if(bytes.length===64){const pub=new Uint8Array(65);pub[0]=4;pub.set(bytes,1);bytes=pub}const point=secp256k1.ProjectivePoint.fromHex(bytes);return hexlify(point.toRawBytes(compressed))}static recoverPublicKey(digest,signature){assertArgument(dataLength(digest)===32,"invalid digest length","digest",digest);const sig=Signature.from(signature);let secpSig=secp256k1.Signature.fromCompact(getBytesCopy(concat([sig.r,sig.s])));secpSig=secpSig.addRecoveryBit(sig.yParity);const pubKey=secpSig.recoverPublicKey(getBytesCopy(digest));assertArgument(pubKey!=null,"invalid signautre for digest","signature",signature);return"0x"+pubKey.toHex(false)}static addPoints(p0,p1,compressed){const pub0=secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p0).substring(2));const pub1=secp256k1.ProjectivePoint.fromHex(SigningKey.computePublicKey(p1).substring(2));return"0x"+pub0.add(pub1).toHex(!!compressed)}}const BN_0=BigInt(0);const BN_36=BigInt(36);function getChecksumAddress(address){address=address.toLowerCase();const chars=address.substring(2).split("");const expanded=new Uint8Array(40);for(let i=0;i<40;i++){expanded[i]=chars[i].charCodeAt(0)}const hashed=getBytes(keccak256(expanded));for(let i=0;i<40;i+=2){if(hashed[i>>1]>>4>=8){chars[i]=chars[i].toUpperCase()}if((hashed[i>>1]&15)>=8){chars[i+1]=chars[i+1].toUpperCase()}}return"0x"+chars.join("")}const ibanLookup={};for(let i=0;i<10;i++){ibanLookup[String(i)]=String(i)}for(let i=0;i<26;i++){ibanLookup[String.fromCharCode(65+i)]=String(10+i)}const safeDigits=15;function ibanChecksum(address){address=address.toUpperCase();address=address.substring(4)+address.substring(0,2)+"00";let expanded=address.split("").map(c=>{return ibanLookup[c]}).join("");while(expanded.length>=safeDigits){let block=expanded.substring(0,safeDigits);expanded=parseInt(block,10)%97+expanded.substring(block.length)}let checksum=String(98-parseInt(expanded,10)%97);while(checksum.length<2){checksum="0"+checksum}return checksum}const Base36=function(){const result={};for(let i=0;i<36;i++){const key="0123456789abcdefghijklmnopqrstuvwxyz"[i];result[key]=BigInt(i)}return result}();function fromBase36(value){value=value.toLowerCase();let result=BN_0;for(let i=0;i<value.length;i++){result=result*BN_36+Base36[value[i]]}return result}function getAddress(address){assertArgument(typeof address==="string","invalid address","address",address);if(address.match(/^(0x)?[0-9a-fA-F]{40}$/)){if(!address.startsWith("0x")){address="0x"+address}const result=getChecksumAddress(address);assertArgument(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/)||result===address,"bad address checksum","address",address);return result}if(address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)){assertArgument(address.substring(2,4)===ibanChecksum(address),"bad icap checksum","address",address);let result=fromBase36(address.substring(4)).toString(16);while(result.length<40){result="0"+result}return getChecksumAddress("0x"+result)}assertArgument(false,"invalid address","address",address)}const regexBytes=new RegExp("^bytes([0-9]+)$");const regexNumber=new RegExp("^(u?int)([0-9]*)$");const regexArray=new RegExp("^(.*)\\[([0-9]*)\\]$");function _pack(type,value,isArray){switch(type){case"address":if(isArray){return getBytes(zeroPadValue(value,32))}return getBytes(getAddress(value));case"string":return toUtf8Bytes(value);case"bytes":return getBytes(value);case"bool":value=!!value?"0x01":"0x00";if(isArray){return getBytes(zeroPadValue(value,32))}return getBytes(value)}let match=type.match(regexNumber);if(match){let signed=match[1]==="int";let size=parseInt(match[2]||"256");assertArgument((!match[2]||match[2]===String(size))&&size%8===0&&size!==0&&size<=256,"invalid number type","type",type);if(isArray){size=256}if(signed){value=toTwos(value,size)}return getBytes(zeroPadValue(toBeArray(value),size/8))}match=type.match(regexBytes);if(match){const size=parseInt(match[1]);assertArgument(String(size)===match[1]&&size!==0&&size<=32,"invalid bytes type","type",type);assertArgument(dataLength(value)===size,`invalid value for ${type}`,"value",value);if(isArray){return getBytes(zeroPadBytes(value,32))}return value}match=type.match(regexArray);if(match&&Array.isArray(value)){const baseType=match[1];const count=parseInt(match[2]||String(value.length));assertArgument(count===value.length,`invalid array length for ${type}`,"value",value);const result=[];value.forEach(function(value){result.push(_pack(baseType,value,true))});return getBytes(concat(result))}assertArgument(false,"invalid type","type",type)}function solidityPacked(types,values){assertArgument(types.length===values.length,"wrong number of values; expected ${ types.length }","values",values);const tight=[];types.forEach(function(type,index){tight.push(_pack(type,values[index]))});return hexlify(concat(tight))}function solidityPackedKeccak256(types,values){return keccak256(solidityPacked(types,values))}function getGlobal(){if(typeof self!=="undefined"){return self}if(typeof window!=="undefined"){return window}if(typeof global!=="undefined"){return global}throw new Error("unable to locate global object")}const anyGlobal=getGlobal();const crypto=anyGlobal.crypto||anyGlobal.msCrypto;function encryptAES(plaintext,key){const blockSize=16;const keyBytes=CryptoJS.enc.Hex.parse(key);const r=CryptoJS.lib.WordArray.random(blockSize);const encryptedR=CryptoJS.AES.encrypt(r,keyBytes,{mode:CryptoJS.mode.ECB,padding:CryptoJS.pad.NoPadding});const plaintextPadded=CryptoJS.enc.Hex.parse(plaintext.padStart(blockSize*2,"0"));const ciphertextWords=encryptedR.ciphertext.words.map((word,i)=>word^plaintextPadded.words[i]);const ciphertext=CryptoJS.lib.WordArray.create(ciphertextWords).toString(CryptoJS.enc.Hex);return{ciphertext:ciphertext,r:r.toString(CryptoJS.enc.Hex)}}function decryptAES(ciphertext,key,r){const blockSize=16;const keyBytes=CryptoJS.enc.Hex.parse(key);const rBytes=CryptoJS.enc.Hex.parse(r);const ciphertextBytes=CryptoJS.enc.Hex.parse(ciphertext);if(ciphertextBytes.sigBytes!==blockSize){throw new RangeError("Ciphertext size must be 128 bits.")}if(keyBytes.sigBytes!==blockSize){throw new RangeError("Key size must be 128 bits.")}if(rBytes.sigBytes!==blockSize){throw new RangeError("Random size must be 128 bits.")}const encryptedR=CryptoJS.AES.encrypt(rBytes,keyBytes,{mode:CryptoJS.mode.ECB,padding:CryptoJS.pad.NoPadding});const plaintextWords=encryptedR.ciphertext.words.map((word,i)=>word^ciphertextBytes.words[i]);const plaintext=CryptoJS.lib.WordArray.create(plaintextWords).toString(CryptoJS.enc.Hex);return plaintext}async function generateRSAKeyPair(){const keyPair=await crypto.subtle.generateKey({name:"RSA-OAEP",modulusLength:2048,publicExponent:new Uint8Array([1,0,1]),hash:{name:"SHA-256"}},true,["encrypt","decrypt"]);const publicKey=await crypto.subtle.exportKey("spki",keyPair.publicKey);const privateKey=await crypto.subtle.exportKey("pkcs8",keyPair.privateKey);return{publicKey:publicKey,privateKey:privateKey}}async function decryptRSA(ciphertext,privateKey){const importedPrivateKey=await importRSAPrivateKey(privateKey);return await crypto.subtle.decrypt({name:"RSA-OAEP"},importedPrivateKey,ciphertext)}function decryptValue(ctAmount,aesKey){const blockSize=16;const hexBase=16;let ctString=ctAmount.toString(hexBase);let ctArray=CryptoJS.enc.Hex.parse(ctString);while(ctArray.sigBytes<32){ctString="0"+ctString;ctArray=CryptoJS.enc.Hex.parse(ctString)}const cipherHex=ctArray.toString(CryptoJS.enc.Hex).substring(0,blockSize*2);const rHex=ctArray.toString(CryptoJS.enc.Hex).substring(blockSize*2);const decryptedMessageHex=decryptAES(cipherHex,aesKey,rHex);return parseInt(decryptedMessageHex,hexBase)}function signRawMessage(message,walletSigningKey){const key=new SigningKey(walletSigningKey);const sig=key.sign(message);return Buffer.concat([getBytes(sig.r),getBytes(sig.s),getBytes(`0x0${sig.v-27}`)])}async function importRSAPrivateKey(privateKeyData){return await crypto.subtle.importKey("pkcs8",privateKeyData,{name:"RSA-OAEP",hash:{name:"SHA-256"}},true,["decrypt"])}function prepareMessage(plaintext,signerAddress,aesKey,contractAddress,functionSelector){const plaintextHex=plaintext.toString(16).padStart(16,"0");const{ciphertext,r}=encryptAES(plaintextHex,aesKey);const ct=ciphertext+r;const messageHash=solidityPackedKeccak256(["address","address","bytes4","uint256"],[signerAddress,contractAddress,functionSelector,BigInt("0x"+ct)]);const encryptedInt=BigInt("0x"+ct);return{encryptedInt:encryptedInt,messageHash:messageHash}}var soda=Object.freeze({__proto__:null,decryptAES:decryptAES,decryptRSA:decryptRSA,decryptValue:decryptValue,encryptAES:encryptAES,generateRSAKeyPair:generateRSAKeyPair,prepareMessage:prepareMessage,signRawMessage:signRawMessage});exports.decryptAES=decryptAES;exports.decryptRSA=decryptRSA;exports.decryptValue=decryptValue;exports.encryptAES=encryptAES;exports.generateRSAKeyPair=generateRSAKeyPair;exports.prepareMessage=prepareMessage;exports.signRawMessage=signRawMessage;exports.soda=soda});